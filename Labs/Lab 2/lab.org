#+TITLE: MECH 420 Lab 2
#+AUTHOR: Jasper Chan - 37467164 @@latex:\\@@ jasperchan515@gmail.com

#+OPTIONS: title:nil toc:nil

#+LATEX_HEADER: \definecolor{bg}{rgb}{0.95,0.95,0.95}
#+LATEX_HEADER: \setminted{frame=single,bgcolor=bg,samepage=true}
#+LATEX_HEADER: \setlength{\parindent}{0pt}
#+LATEX_HEADER: \usepackage{float}
#+LATEX_HEADER: \usepackage{svg}
#+LATEX_HEADER: \usepackage{cancel}
#+LATEX_HEADER: \usepackage{amssymb}
#+LATEX_HEADER: \usepackage{mathtools, nccmath}
#+LATEX_HEADER: \DeclareSIUnit\inch{in}
#+LATEX_HEADER: \sisetup{per-mode=fraction}
#+LATEX_HEADER: \newcommand{\Lwrap}[1]{\left\{#1\right\}}
#+LATEX_HEADER: \newcommand{\Lagr}[1]{\mathcal{L}\Lwrap{#1}}
#+LATEX_HEADER: \newcommand{\Lagri}[1]{\mathcal{L}^{-1}\Lwrap{#1}}
#+LATEX_HEADER: \newcommand{\Ztrans}[1]{\mathcal{Z}\Lwrap{#1}}
#+LATEX_HEADER: \newcommand{\Ztransi}[1]{\mathcal{Z}^{-1}\Lwrap{#1}}
#+LATEX_HEADER: \newcommand{\ZOH}[1]{\text{ZOH}\left(#1\right)}
#+LATEX_HEADER: \newcommand{\approptoinn}[2]{\mathrel{\vcenter{\offinterlineskip\halign{\hfil$##$\cr#1\propto\cr\noalign{\kern2pt}#1\sim\cr\noalign{\kern-2pt}}}}}
#+LATEX_HEADER: \newcommand{\appropto}{\mathpalette\approptoinn\relax}

#+BEGIN_EXPORT latex
\makeatletter
\begin{titlepage}
\begin{center}
\vspace*{2in}
{\Large \@title \par}
\vspace{1in}
{\Large \@author \par}
\vspace{3in}
{\large \@date}
\end{center}
\end{titlepage}
\makeatother
#+END_EXPORT


\tableofcontents

#+begin_src ipython :session :results raw drawer :exports none
import numpy as np
import scipy.optimize
from numpy.polynomial.polynomial import Polynomial as P
import pandas as pd
import matplotlib
from matplotlib import pyplot as plt
import prox_tv as ptv
from IPython.display import set_matplotlib_formats
%matplotlib inline
set_matplotlib_formats('svg')
matplotlib.rcParams.update({'errorbar.capsize': 2})
#+end_src

#+RESULTS:
:results:
# Out[1]:
:end:

#+begin_src ipython :session :results raw drawer :exports none
import IPython
from tabulate import tabulate

class OrgFormatter(IPython.core.formatters.BaseFormatter):
    def __call__(self, obj):
        if(isinstance(obj, str)):
            return None
        try:
            return tabulate(obj, headers='keys',
                            tablefmt='orgtbl', showindex='always')
        except:
            return None

ip = get_ipython()
ip.display_formatter.formatters['text/org'] = OrgFormatter()
#+end_src

#+RESULTS:
:results:
# Out[2]:
:end:



Note: when not specified, all units are SI without prefixes.
* Characterization of the Optical Encoder Signal
** Experimental Procedure
This was conducted by the lab TAs
** Analysis
*** Encoder Shaft Direction Plots
First let's load in the provided data:
#+begin_src ipython :session :exports both :results raw drawer
df_cw = pd.read_csv('data/e1_hand_clockwise.csv')
df_ccw = pd.read_csv('data/e1_hand_counter.csv')
#+end_src

#+RESULTS:
:results:
# Out[3]:
:end:
Plotting the results:
#+begin_src ipython :session :ipyfile hand_clockwise.svg :exports both :results none
def plot_enc_hand(df, t_f=0.003):
    t = df["Time (sec)"]
    a = df["Channel A"]
    b = df["Channel B"]
    ax1 = plt.subplot(211)
    plt.plot(t, a)
    plt.xlim((0, t_f))
    plt.setp(ax1.get_xticklabels(), visible=False)
    plt.ylabel("Channel A")
    ax2 = plt.subplot(212, sharex=ax1)
    plt.plot(t, b)
    plt.ylabel("Channel B")
plot_enc_hand(df_cw)
#+end_src

#+ATTR_LATEX: :placement [H]
#+NAME: fig:hand_clockwise
#+CAPTION: Encoder output for clockwise rotation
[[file:hand_clockwise.svg]]
#+begin_src ipython :session :ipyfile hand_counterclockwise.svg :exports both :results none
plot_enc_hand(df_ccw)
#+end_src

#+ATTR_LATEX: :placement [H]
#+NAME: fig:hand_counterclockwise
#+CAPTION: Encoder output for counter-clockwise rotation
[[file:hand_counterclockwise.svg]]

As seen in Figure [[fig:hand_clockwise]], channel A rises first, then channel B.
In Figure [[fig:hand_counterclockwise]], channel B rises first, then channel A.
*** Angular Speed Calculation
First let's define some objects that will be used later on[fn:single_pickoff]:
#+begin_src ipython :session :exports both :results raw drawer
N = 360  # from lab-manual, number of pulses per revolution
def extract_enc_df(df):
    return (np.array(df["Time (sec)"]),
            np.array(df["Channel A"]), np.array(df["Channel B"]))
#+end_src

#+RESULTS:
:results:
# Out[6]:
:end:

For the pulse counting method of angular velocity measurement, the angular velocity $\Omega_c$ is given by:
\begin{equation}
\Omega_c = \frac{2 \pi n}{N T}
\end{equation}

Where:
\begin{align*}
n &:= \text{The number of pulses counted within the time period T} \\
N &:= \text{The number of pulses generated by one revolution} \\
T &:= \text{The time period over which the measurement is done.} \\
\end{align*}

I will be taking $T$ to be the entire length of each provided dataset, which seems to be constant at $\SI{2.4975}{\milli\second}$
#+begin_src ipython :session :exports both :results raw drawer
def enc_speed_count(t, sig_a):
    T = max(t) - min(t)
    sig_a = sig_a - 0.5
    pos = sig_a > 0
    zero_crossings = (pos[:-1] & ~pos[1:]).nonzero()[0]
    n = len(zero_crossings)
    omega_c = 2*np.pi*n/(N*T)
    return omega_c
#+end_src

#+RESULTS:
:results:
# Out[7]:
:end:

For the pulse timing method of angular velocity measurement, the angular velocity $\Omega_t$ is given by:
\begin{equation}
\Omega_c = \frac{2 \pi f}{N m}
\end{equation}
Where:
\begin{align*}
f &:= \text{The sample frequency used} \\
m &:= \text{The number of samples within one pulse cycle} \\
\end{align*}

I will be taking $f$ to be the sample frequency of each provided dataset, which seems to be constant at $\SI{400}{\kilo\hertz}$
#+begin_src ipython :session :exports both :results raw drawer
def enc_speed_time(t, sig_a):
    f = 1/(t[1] - t[0])
    sig_a = sig_a - 0.5
    pos = sig_a > 0
    zero_crossings = (pos[:-1] & ~pos[1:]).nonzero()[0]
    m = np.diff(zero_crossings)
    # Use average count 
    avg_m = np.mean(m)
    omega_t = 2*np.pi*f/(N*avg_m)
    return omega_t, avg_m
#+end_src

#+RESULTS:
:results:
# Out[8]:
:end:

Now we can import the data and calculate the velocities at each voltage
#+begin_src ipython :session :exports both :results raw drawer
t05, sig_A05, _ = extract_enc_df(
    pd.read_csv('data/e1_motor_0.5V.csv'))
t07, sig_A07, _ = extract_enc_df(
    pd.read_csv('data/e1_motor_0.7V.csv'))
t09, sig_A09, _ = extract_enc_df(
    pd.read_csv('data/e1_motor_0.9V.csv'))

o05_c = enc_speed_count(t05, sig_A05)
o07_c = enc_speed_count(t07, sig_A07)
o09_c = enc_speed_count(t09, sig_A09)
o05_t, m05 = enc_speed_time(t05, sig_A05)
o07_t, m07 = enc_speed_time(t07, sig_A07)
o09_t, m09 = enc_speed_time(t09, sig_A09)

v = np.array([0.5, 0.7, 0.9])
o_c = np.array([o05_c, o07_c, o09_c])  # rad/s
o_t = np.array([o05_t, o07_t, o09_t])  # rad/s
#+end_src

#+RESULTS:
:results:
# Out[9]:
:end:

Plotting the results:
#+begin_src ipython :session :ipyfile count_vs_time_enc.svg :exports both :results none
plt.scatter(v, o_c, label="Pulse Counting", s=20)
plt.scatter(v, o_t, label="Pulse Timing", s=20)
plt.xlabel("Motor Voltage [V]")
plt.ylabel("Motor Speed [rad/s]")
plt.legend()
#+end_src

#+ATTR_LATEX: :placement [H]
#+CAPTION: Comparison of pulse counting and pulse timing for angular velocity measurement.
[[file:count_vs_time_enc.svg]]


[fn:single_pickoff] Here I am using measurements from a single pickoff for simplicity (i.e. using $N$ instead of $4N$ in the calculations).

*** Velocity Resolution Calculations
For the pulse counting method of angular velocity measurement, the angular velocity resoluion $\Delta\Omega_c$ is given by:
#+NAME: eq:domega_c
\begin{equation}
\Delta \Omega_c = \frac{2 \pi}{N T}
\end{equation}
Calculating this[fn:count_res]:
#+begin_src ipython :session :exports both :results raw drawer
T = max(t05) - min(t05)
domega_c = 2*np.pi/(N*T)  # rad/s
#+end_src

#+RESULTS:
:results:
# Out[11]:
:end:

For the pulse counting method of angular velocity measurement, the angular velocity resoluion $\Delta\Omega_t$ is given by:
\begin{equation}
\Delta \Omega_t = \frac{2 \pi f}{N m (m + 1)}
\end{equation}
Calculating this:
#+begin_src ipython :session :exports both :results raw drawer
f = 1/(t05[1] - t05[0])
m = np.array([m05, m07, m09])
domega_t = 2*np.pi*f/(N*m*(m + 1))  # rad/s
#+end_src

#+RESULTS:
:results:
# Out[12]:
:end:

For large sample counts $m$, $\Delta \Omega_t$ can be approximated as:
\begin{equation}
\Delta \Omega_t \approx \frac{2 \pi f}{N m^2} = \frac{N \Omega_t^2}{2 \pi f}
\end{equation}
Calculating this:
#+begin_src ipython :session :exports both :results raw drawer
approx_domega_t = 2*np.pi*f/(N*m**2)  # rad/s
#+end_src

#+RESULTS:
:results:
# Out[13]:
:end:

Showing the results:
#+begin_src ipython :session :exports both :results raw drawer
pd.DataFrame(
    np.vstack(
        (o_c, o_t, np.ones(len(v))*domega_c, domega_t, approx_domega_t)).T,
    columns=[
             r'$\Omega_c$', r'$\Omega_t$', r'$\Delta\Omega_c$',
             r'$\Delta\Omega_t$', r'$\sim\Delta\Omega_t$'])
#+end_src

#+RESULTS:
:results:
# Out[14]:
|    |   $\Omega_c$ |   $\Omega_t$ |   $\Delta\Omega_c$ |   $\Delta\Omega_t$ |   $\sim\Delta\Omega_t$ |
|----+--------------+--------------+--------------------+--------------------+------------------------|
|  0 |      272.544 |      269.878 |            6.98831 |            10.0444 |                10.4327 |
|  1 |      293.509 |      293.875 |            6.98831 |            11.8708 |                12.3705 |
|  2 |      293.509 |      294.177 |            6.98831 |            11.8947 |                12.3959 |
:end:


We can see that both the exact and approximate calculations for $\Delta \Omega_t$ give similar results, and that resolution degrades for higher speeds/fewer sample counts.


[fn:count_res] The resolution is only dependent on $N$ and $T$ which are constant for all measurements, hence only one calculation is needed.
* Characterization of the Torque Sensor
<<sec:torq_sens_charac>>
** Experimental Procedure
This was conducted by the lab TAs
** Analysis
Let's first load the data[fn:tasmessedupagain]:
#+begin_src ipython :session :exports both :results raw drawer
g = 9.81  # m/s^2
def extract_torque_df(df):
    return (np.array(df["Applied Torque (Nm)"])*g,
            np.array(df["Load Cell 0 (V)"]),
            np.array(df["Load Cell 1 (V)"]))

tau_0, lc0_0, lc1_0 = extract_torque_df(
    pd.read_csv('data/e2_torque_0.csv'))
tau_l1, lc0_l1, lc1_l1 = extract_torque_df(
    pd.read_csv('data/e2_torque_one_by_one_left.csv'))
tau_l2, lc0_l2, lc1_l2 = extract_torque_df(
    pd.read_csv('data/e2_torque_one_by_one_left_2.csv'))
tau_r1, lc0_r1, lc1_r1 = extract_torque_df(
    pd.read_csv('data/e2_torque_one_by_one_right.csv'))
tau_r2, lc0_r2, lc1_r2 = extract_torque_df(
    pd.read_csv('data/e2_torque_one_by_one_right_2.csv'))
# Take clockwise torques as negative
tau_r1 = -tau_r1
tau_r2 = -tau_r2
#+end_src

#+RESULTS:
:results:
# Out[15]:
:end:

We can calculate the measured torque by:
#+begin_src ipython :session :exports both :results raw drawer
L_L = 0.057  # m, distance of torque sensor from center, from lab manual
V_s = 10  # V, bridge supply voltage
K_i = 100  # load cell amplifier gain
F_nom = 7*g  # N, nominal load/capacity
K_l = 0.002165/F_nom  # V(output)/V(bridge voltage)/N, load cell gain

def calc_volt(lc0, lc1):
    dif = lc0 - lc1  # reject common mode noise
    V_o = dif/K_i  # undo amplifier gain
    return V_o

def calc_torque(lc0, lc1):
    V_o = calc_volt(lc0, lc1)
    F = V_o/V_s/K_l  # convert load cell voltage to force
    tau = F*L_L
    return tau

calc_tau_0 = calc_torque(lc0_0, lc1_0)
calc_tau_l1 = calc_torque(lc0_l1, lc1_l1)
calc_tau_l2 = calc_torque(lc0_l2, lc1_l2)
calc_tau_r1 = calc_torque(lc0_r1, lc1_r1)
calc_tau_r2 = calc_torque(lc0_r2, lc1_r2)
#+end_src

#+RESULTS:
:results:
# Out[16]:
:end:

[fn:tasmessedupagain] The TAs seem to have forgotten to multiply the data in the applied torque column by gravitational acceleration $g$, supposedly due to incorrect data aquisition code.
This seems rather unlikely given that the value in that column is calculated by hand and manually entered into the program.
In any case, I have corrected the error for them.





*** Torque Sensor Plot
#+begin_src ipython :session :ipyfile torque_sensor_plot.svg :exports both :results none
p = lambda t, c, m, l: plt.scatter(
    t, c, edgecolors=m, facecolors='none', label=l)

ofst = 0.03 # offset plots for visibility
p(tau_0, calc_tau_0, 'r', 'zero')
p(tau_l1 + ofst, calc_tau_l1, 'g', 'left')
p(tau_l2 - ofst, calc_tau_l2, 'b', 'left2')
p(tau_r1 + ofst, calc_tau_r1, 'c', 'right')
p(tau_r2 - ofst, calc_tau_r2, 'y', 'right2')
plt.legend()
plt.xlabel('Applied Torque [Nm]')
plt.ylabel('Measured Torque [Nm]')
#+end_src

#+NAME: fig:torque_sensor_plot
#+CAPTION: Torque sensor measured torque vs. applied torque.
[[file:torque_sensor_plot.svg]]

In Figure [[fig:torque_sensor_plot]] we can see there are significant outliers in in both the ~left~ and ~right~ data sets.
It appears that the TAs entered the incorrect torque values while doing the measurement.
Ideally, we would go and manually remove/correct the incorrect data, however because the errors are isolated to the first load cycles, and the lab manual only asks for analysis to be done with "the second load cycle only"[fn:secondsetonly], I will neglect this.
[fn:secondsetonly] Pg.14 of lab manual




*** Calibration Curve Fit
We want to find the calibration curve $V_\tau(\tau)$, which is the voltage output at some input torque.
I will be finding the calibrtion curve for the differenced outputs of each load cell (common mode noise rejected), and without the instrumentation amplifier gain, which is just a constant.

#+begin_src ipython :session :ipyfile cal_curve.svg :exports both :results none
tau = np.hstack((tau_l2, tau_r2))

V_l2 = calc_volt(lc0_l2, lc1_l2)
V_r2 = calc_volt(lc0_r2, lc1_r2)
V = np.hstack((V_l2, V_r2))
V_T = P.fit(tau, V, 1)
b, a = V_T.convert().coef
f_name = f'$V_\\tau(\\tau)$ = {a:f}*$\\tau$ + {b:.3e}'
p(tau, V, 'r', 'Raw Data')
plt.plot(tau, V_T(tau), label='Best Fit')
plt.legend()
plt.text(-2, min(V), f_name)
plt.xlabel('Torque [Nm]')
plt.ylabel('Voltage [V]')
#+end_src

#+NAME: fig:cal_curve
#+ATTR_LATEX: :placement [H]
#+CAPTION: Voltage calibration curve fit of torque sensor.
[[file:cal_curve.svg]]

*** Error Plots
The absolute nonlinearity error can be calculated by:
#+begin_src ipython :session :exports both :results raw drawer
nl_taus = np.sort(np.unique(tau))
# Calculate average V at each tau
nl_avg_V = np.array([np.mean(V[np.where(tau == t)]) for t in nl_taus])
nonlin = np.abs(V_T(nl_taus) - nl_avg_V)
#+end_src

#+RESULTS:
:results:
# Out[20]:
:end:

The absolute hysteresis error can be calculated by[fn:abshyst]:
#+begin_src ipython :session :exports both :results raw drawer
# Calculate hysteresis error for each side of measurement
def _calc_hyst(tau, V):
    # Find locations between measurements
    c_idxs = np.where(tau[:-1] != tau[1:])[0] + 1
    c_idxs = np.insert(c_idxs, 0, 0)
    c_idxs = np.append(c_idxs, len(tau))

    # Get average voltage of each measurement
    taus = []
    avg_V = []
    for i0, i1 in zip(c_idxs[:-1], c_idxs[1:]):
        taus.append(np.mean(tau[i0:i1]))
        avg_V.append(np.mean(V[i0:i1]))

    # Find difference between initial and final
    # measurements at each torque
    hyst = []
    for v0, v1 in zip(avg_V, reversed(avg_V)):
        hyst.append(np.abs(v0 - v1))
    return np.array(taus), np.array(hyst), avg_V

def calc_hyst(tau_l, tau_r, V_l, V_r):
    h_taus_l, h_err_l, avg_V_l = _calc_hyst(tau_l, V_l)
    h_taus_r, h_err_r, avg_V_r = _calc_hyst(tau_r, V_r)
    # Hysteresis at zero
    hyst_0 = np.abs(avg_V_l[-1] - avg_V_r[-1])

    # Combine calculated error arrays
    h_taus = np.hstack((h_taus_r, h_taus_l))
    h_err = np.hstack((h_err_r, h_err_l))

    # Overwrite zeros with correct value
    h_err = np.where(h_taus==0, hyst_0, h_err)
    return h_taus, h_err

h_taus, h_err = calc_hyst(tau_l2, tau_r2, V_l2, V_r2)
#+end_src

#+RESULTS:
:results:
# Out[21]:
:end:

Plotting our rseults:
#+begin_src ipython :session :ipyfile nonlin_hyst_err.svg :exports both :results none
plt.plot(nl_taus, nonlin, 'o-', label='nonlinearity')
plt.plot(h_taus, h_err, 'o-', label='hysteresis')
plt.xlabel('Torque [Nm]')
plt.ylabel('Error [V]')
plt.legend()
#+end_src

#+NAME: fig:nonlin_hyst_err
#+ATTR_LATEX: :placement [H]
#+CAPTION: Nonlinearity and hysteresis error of torque sensor
[[file:nonlin_hyst_err.svg]]

Note that Figure [[fig:nonlin_hyst_err]] implies that the hysteresis error is zero at the extremes of the graph.
This is due to the fact that we only ever approach the extreme values from one direction.
Theoretically if we were to load the sensor past those values and return to them we would see that there is some hysteresis, however the graph already shows the effective max rated torque of the sensor.


[fn:abshyst] Since we have two separate datasets for loading the sensor in opposite directions, the hysteresis at the first zero measurement of each dataset is poorly defined since we don't know whether that zero was approached from a positive or negative torque.
Instead, I will compare the final zero measurements from each dataset against each other since we know which direction the value was approached from.
*** Comparison of Theoretical and Measured Transfer Characteristics
**** Sensitivity \par
The theoretical sensitivity can be calculated by:
#+begin_src ipython :session :exports both :results raw drawer
S = K_l*V_s/L_L  # V/Nm
S
#+end_src

#+RESULTS:
:results:
# Out[44]:
: 0.005531157148733199
:end:

This is fairly close to the measured sensitivity which can be seen in Figure [[fig:cal_curve]].
#+begin_src ipython :session :exports both :results raw drawer
a  # V/Nm
#+end_src

#+RESULTS:
:results:
# Out[24]:
: 0.006292213840341486
:end:

**** Offset \par
The max theoretical offset can be calculated by:
#+begin_src ipython :session :exports both :results raw drawer
zero_balance = 0.03  # fraction of FSO, from datasheet
V_0 = F_nom*K_l*V_s  # V, Voltage output at FSO

# Value needs to be multiplied by two to account for the offsets
# potentially being at opposite extremes of the offset range
offset_V = 2*zero_balance*V_0  # V, max absolute offset error
offset_V
#+end_src

#+RESULTS:
:results:
# Out[61]:
: 0.0012989999999999998
:end:

The measured offset can be seen in Figure [[fig:cal_curve]]:
#+begin_src ipython :session :exports both :results raw drawer
b  # V
#+end_src

#+RESULTS:
:results:
# Out[62]:
: 0.0012535859936444445
:end:

The value is just under the theoretical limit.
This inidicates that the load cells have drifted to either extreme of their rated offset range.
**** Nonlinearity \par
The max theoretical nonlinearity error in one direction can be calculated by:
#+begin_src ipython :session :exports both :results raw drawer
nonlinearity = 0.0002  # fraction of FSO, from datasheet

# Value needs to be multiplied by two to account for the errors
# potentially being at opposite extremes of the error range
max_nonlin = 2*nonlinearity*V_0  # V, max absolute nonlinearity error
max_nonlin
#+end_src

#+RESULTS:
:results:
# Out[64]:
: 8.66e-06
:end:

Our max measured nonlinearity error can be seen in Figure [[fig:nonlin_hyst_err]]:
#+begin_src ipython :session :exports both :results raw drawer
max(nonlin)  # V
#+end_src

#+RESULTS:
:results:
# Out[65]:
: 8.873165444445164e-05
:end:

Our measured value is significantly higher than the rated error.
It's not clear why this is, but given that the offsets of the load cells seem to have deviated significantly the errors may have exceeded their rated values from wear or mishandling.

**** Hysteresis \par
The max theoretical hysteresis error in one direction can be calculated by:
#+begin_src ipython :session :exports both :results raw drawer
hysteresis = 0.00015  # fraction of FSO, from datasheet

# Value needs to be multiplied by two to account for the errors
# potentially being at opposite extremes of the error range
max_hyst = 2*hysteresis*V_0  # V, max absolute hysteresis error
max_hyst
#+end_src

#+RESULTS:
:results:
# Out[66]:
: 6.494999999999999e-06
:end:

Our max measured nonlinearity error can be seen in Figure [[fig:nonlin_hyst_err]]:
#+begin_src ipython :session :exports both :results raw drawer
max(h_err)  # V
#+end_src

#+RESULTS:
:results:
# Out[67]:
: 3.8531601200000876e-05
:end:

Our measured error is significantly higher than the rated error.
It's not clear why this is, but given that the offsets of the load cells seem to have deviated significantly the errors may have exceeded their rated values from wear or mishandling.

* Measurement of the Torque Required to Drive the Conveyor
** Experimental Procedure
This was conducted by the lab TAs
** Data Analysis
We need to convert the voltages measured in our data to motor torques, which means solving for $\tau$ in our calibration curve $V_\tau(\tau)$.
This could be done by hand, but it is much easier to just redo the fit with the correct axes:

#+begin_src ipython :session :exports both :results output latex
tau_V = P.fit(V, tau, 1)
tau_b, tau_a = tau_V.convert().coef
print(f'$\\tau_V(V) = ({tau_a:f})V + ({tau_b:.3f})$')
#+end_src

#+RESULTS:
#+begin_export latex
$\tau_V(V) = (158.917877)V + (-0.199)$
#+end_export

Let's load our data:
#+begin_src ipython :session :exports both :results raw drawer
conv_df = pd.read_csv('data/e3_50RPM.csv')
conv_t = conv_df['Time (s)']
conv_speed = conv_df['Motor Speed (RPM)']
conv_lc0 = conv_df['Load Cell 1']
conv_lc1 = conv_df['Load Cell 2']
#+end_src

#+RESULTS:
:results:
# Out[34]:
:end:

*** Torque Plot
Calculating the torque and plotting the results:
#+begin_src ipython :session :ipyfile conv_torque.svg :exports both :results none
conv_V = calc_volt(conv_lc0, conv_lc1)
conv_tau = tau_V(conv_V)
plt.plot(conv_t, conv_tau)
plt.xlabel('Time [s]')
plt.ylabel('Torque [Nm]')
#+end_src


#+ATTR_LATEX: :placement [H]
#+CAPTION: Torque required to drive the conveyor belt over one cycle at 50 RPM (500 RPM motor speed)
[[file:conv_torque.svg]]
There is significant noise in the plot, which suggests that the system does not run smoothly.
This is supported by the fact that the conveyor system sounds very loud when it is running in the provided video on Canvas.
*** Average Torque and Standard Deviation
Calculating the average torque:
#+begin_src ipython :session :exports both :results raw drawer
np.mean(conv_tau)  # Nm
#+end_src

#+RESULTS:
:results:
# Out[36]:
: 0.1629002604046592
:end:

Calculating the torque standard deviation:
#+begin_src ipython :session :exports both :results raw drawer
np.std(conv_tau)  # Nm
#+end_src

#+RESULTS:
:results:
# Out[37]:
: 0.05492220131020989
:end:

* Additional Exercises
** Assume that you use the quadrature signals of an optical encoder with 360 windows, and timing frequency of 400 Hz, and a counting period of 2.5 ms. Determine the angular velocity at which the velocity resolution for both pulse counting and for pulse timing is identical; assume the simplified formula for the pulse timing method. Which method will be more accurate at higher rotational velocities?
:PROPERTIES:
 :ALT_TITLE: Question 1
:END:
Let's calculate the counting resolution $\Delta \Omega_c$:
#+begin_src ipython :session :exports both :results raw drawer
N = 360  # Window count
T = 0.0025  # ms, counting period
domega_c = 2*np.pi/(4*N*T)  # rad/s counting resolution
domega_c
#+end_src

#+RESULTS:
:results:
# Out[38]:
: 1.7453292519943295
:end:

Now we can solve for the angular velocity $\Omega_t$ where the timing resolution $\Delta \Omega_t = \Delta \Omega_c$:
\begin{equation}
\Omega_t = \sqrt{
\frac{2 \Delta \Omega_c \pi f}{4N}
}
\end{equation}
#+begin_src ipython :session :exports both :results raw drawer
f = 400  # Hz
omega_t = np.sqrt(domega_c*2*np.pi*f/(4*N))  # rad/s 
omega_t
#+end_src

#+RESULTS:
:results:
# Out[39]:
: 1.7453292519943295
:end:

The counting method will have a better resolution at higher velocities.
** Determine the "static" transfer characteristics of the torque sensor through the following steps
:PROPERTIES:
 :ALT_TITLE: Question 2
:END:
*** Use the free body diagram in Figure [[fig:cantilever]] for the torque arm of the torque calibration bar, including the applied weight $F_W$ and the forces $F_1$ and $F_2$ applied to the load cells of the torque sensor as well as the vertical load onto the motor shaft $F_A$. Determine the torque $T$ applied to the motor mount by the weights on the torque arm in terms of the forces $F_1$ and $F_2$.
:PROPERTIES:
 :ALT_TITLE: Question 2.1
:END:

#+NAME: fig:cantilever
#+ATTR_LATEX: :placement [H] :width 0.6\textwidth
#+CAPTION: Free body diagram for the torque sensor in Section [[sec:torq_sens_charac]]
[[file:cantilever.png]]

For static loading, the force balance is:
\begin{equation}
\sum F = 0 = F_1 + F_2 + F_W - F_A
\end{equation}
The torque balance about the central point (x in Figure [[fig:cantilever]]) is:

\begin{equation}
\sum M = 0 = F_1 L_L - F_2 L_L - \underbrace{F_W L_W}_{\tau}
\end{equation}
Solving for input torque $\tau$, we get:
\begin{equation}
\tau = L_L(F_1 - F_2)
\end{equation}
*** Provide expressions for the voltages $V_1$ and $V_2$ at the output of the two load cells as a function of the forces $F_1$ and $F_2$, the sensitivities $B_1$ and $B_2$, the offsets $V_{1_0}$ and $V_{2_0}$ of the load cell outputs, and the errors $\Delta V_1$ and $\Delta V_2$.
:PROPERTIES:
 :ALT_TITLE: Question 2.2
:END:
The voltage output $V_i$ of each load cell is:
\begin{equation}
V_i(F_i) = B_i F_i + V_{i_0} + \Delta V_i
\end{equation}
*** The output voltage of the torque sensor is the amplified (gain $G$) difference between the output voltages of both load cells. Write down this voltage as a function of the torque $\tau$ assuming an identical sensitivity for both load cells
:PROPERTIES:
 :ALT_TITLE: Question 2.3
:END:
Assuming $B = B_1 = B_2$
\begin{align*}
V_o(\tau) &= G(V_1(F_1) - V_2(F_2)) \\
&= G((B F_1 + V_{1_0} + \Delta V_1) - (B F_2 + V_{2_0} + \Delta V_2)) \\
&= G(B (F_1 - F_2)  + (V_{1_0} + \Delta V_1) - (V_{2_0} + \Delta V_2)) \\
&= G(\frac{B}{L_L} \underbrace{L_L(F_1 - F_2)}_{\tau} + (V_{1_0} + \Delta V_1) - (V_{2_0} + \Delta V_2)) \\
&= G(\frac{B}{L_L} \tau + (V_{1_0} + \Delta V_1) - (V_{2_0} + \Delta V_2)) \\
\end{align*}
*** From this expression determine the expression for sensitivity $S$ of the torque sensor and determine its numerical value with units using the data sheet and the geometry of the setup, keeping in mind that the supply voltage for the load cells is \SI{10}{\volt}
:PROPERTIES:
 :ALT_TITLE: Question 2.4
:END:
The sensitivity $S$ of the torque sensor is found by taking the derivative of $V_o(\tau)$ with respsect to $\tau$:
\begin{equation}
S = \frac{d V_o(\tau)}{d \tau} = G\frac{B}{L_L}
\end{equation}
Calculating the load cell sensitivity $B$:[fn:v_nom]:
#+begin_src ipython :session :exports both :results raw drawer
V_nom = 0.002  # V/V, output voltage at nominal load per input
               # voltage, from datasheet
F_nom = 7*g  # N, nominal load, from datasheet
V_s = 10  # V, bridge input voltage, from lab manual

B = V_nom*V_s/F_nom  # V/N, load cell sensitivity
B
#+end_src

#+RESULTS:
:results:
# Out[42]:
: 0.000291247997670016
:end:
Calculating the total load cell sensitivity $S$:

#+begin_src ipython :session :exports both :results raw drawer
G = 100  # Amplifier gain, from lab manual
L_L = 0.057  # m, distance from load cell to axis, from lab manual
S_theor = G*B/L_L  # V/Nm, torque sensor sensitivity
S_theor
#+end_src

#+RESULTS:
:results:
# Out[47]:
: 0.5109613994210807
:end:

[fn:v_nom] The lab manual specifies a $V_\text{nom} = \SI{2.165}{\milli\volt\per\volt}$.
I assume the load cells in the lab have had further testing to determine their properties to a greater degree of precision, and have used that value for all of the data analysis.
However, for these theoretical calculations I will be using the nominal value of $\SI{2}{\milli\volt\per\volt}$ provided in the datasheet.

*** Determine the maximum expected offset voltage of the torque sensor using the data sheet for the load cells.
:PROPERTIES:
 :ALT_TITLE: Question 2.5
:END:
#+begin_src ipython :session :exports both :results raw drawer
zero_balance = 0.03  # fraction of FSO, from datasheet
V_0 = zero_balance*V_nom*V_s  # V, max absolute zero offset of load cell

# Value needs to be multiplied by two to account for the offsets
# potentially being at opposite extremes of the offset range
V_tau_0 = 2*G*V_0  # V, max absolute zero offset of torque sensor.
V_tau_0
#+end_src

#+RESULTS:
:results:
# Out[48]:
: 0.12000000000000001
:end:
*** Also, estimate the maximum nonlinearity error and the hysteresis error of the torque sensor in terms of output voltage using the data sheet for the load cells.
:PROPERTIES:
 :ALT_TITLE: Question 2.6
:END:
**** Nonlinearity \par
The max theoretical nonlinearity error in one direction can be calculated by:
#+begin_src ipython :session :exports both :results raw drawer
nonlinearity = 0.0002  # fraction of FSO, from datasheet
dV_nonlin = nonlinearity*V_nom*V_s  # V, absolute nonlinearity error of load cell

# Value needs to be multiplied by two to account for the errors
# potentially being at opposite extremes of the error range
dV_tau_nonlin = 2*G*dV_nonlin  # V, max nonlinearity error of torque sensor.
dV_tau_nonlin
#+end_src

#+RESULTS:
:results:
# Out[49]:
: 0.0008000000000000001
:end:

**** Hysteresis \par
The max theoretical hysteresis error in one direction can be calculated by:
#+begin_src ipython :session :exports both :results raw drawer
hysteresis = 0.00015  # fraction of FSO, from datasheet
dV_nonlin = hysteresis*V_nom*V_s  # V, absolute hysteresis error of load cell

# Value needs to be multiplied by two to account for the errors
# potentially being at opposite extremes of the error range
dV_tau_hysteresis = 2*G*dV_nonlin  # V, max nonlinearity error of torque sensor.
dV_tau_hysteresis
#+end_src

#+RESULTS:
:results:
# Out[50]:
: 0.0006000000000000001
:end:
** Search and obtain the data sheets and images of the following items: 1. A DC motor with a built-in encoder; 2. A PWM amplifier (or drive hardware) for the motor; 3. A microcontroller. Suppose that the microcontroller is programmed to acquire the signals from the motor encoder, and based on that information and the required motion profile, a signal is generated for the PWM amplifier to drive the motor accordingly. Provide a schematic diagram that contains the images of these three components and any other required hardware for this system. In the diagram, show how the components are interconnected, using lines to represent cable strands (signal paths).
:PROPERTIES:
 :ALT_TITLE: Question 3
:END:
*** Motor
I will be using the DG01D-E sold by Sparkfun[fn:motorlink].
The datasheet can be found at https://cdn.sparkfun.com/assets/8/3/b/e/4/DS-16413-DG01D-E_Motor_with_Encoder.pdf.

#+ATTR_LATEX: :placement [H] :width 0.7\textwidth
#+CAPTION: DG01D-E motor.
[[file:motor.jpg]]

Note: this motor uses hall effect sensors for its encoder.
Looking at the datasheet shows that the output of the encoder is effectively identical to the motor used in this lab

[fn:motorlink] https://www.sparkfun.com/products/16413

*** PWM Amplifier
I will be using the DRV8871 DC motor driver IC, breakout sold by Adafruit[fn:drvlink].
The datasheet can be found at https://cdn-shop.adafruit.com/product-files/3190/drv8871.pdf

#+ATTR_LATEX: :placement [H] :width 0.7\textwidth
#+CAPTION: Adafruit DRV8871 breakout board
[[file:drv.jpg]]

[fn:drvlink] https://www.adafruit.com/product/3190

*** Microcontroller
I will be using an Arduino Uno R3 (ATmega328P), sold by Adafruit[fn:mculink].
The datasheet for the MCU itself can be found at https://cdn-shop.adafruit.com/product-files/4806/4806_Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf

#+ATTR_LATEX: :placement [H] :width 0.7\textwidth
#+CAPTION: Arduino Uno R3
[[file:arduino.jpg]]

[fn:mculink] https://www.adafruit.com/product/4806

*** Schematic
#+CAPTION: Wiring schematic for motor controller system
[[file:motor_driver_circuit_fixed.svg]]

